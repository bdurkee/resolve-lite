Precis Basic_Integer_Theory;
        uses Monogenerator_Theory, Basic_Binary_Relation_Properties, Basic_Natural_Number_Theory;
    /** many theorems elided */
    Categorical Definition for Z : SSet, 0 : Z, NB : Z ⟶ Z is
        Is_Monogeneric_for(Z, 0, NB);

    Inductive Definition Is_Neg(n : Z) : B is
        (i.) Is_Neg(n);
        (ii.) Is_Neg(NB(n)) = ⌐(Is_Neg(n));

    Inductive Definition ⨩(n : Z) : Z is
        (i.) ⨩(0) = 0;
        (ii.) ⨩(NB(n)) = {{n if Is_Neg(n); NB(NB(n)) otherwise; }};

	Classification Corollary :
		N : Z;

    Inductive Definition suc(n : Z) : Z is
        (i.) suc(0) = NB(NB(0));
        (ii.) suc(NB(n)) = {{NB(NB(NB(n))) if Is_Neg(n); ⨩(n) otherwise;}};

    Inductive Definition (m : Z) + (n : Z) : Z is
        (i.) m + 0 = m;
        (ii.) m + NB(n) = {{⨩(m) + n if Is_Neg(n);
                suc(⨩(m) + n) otherwise;}};

    Definition (m : Z) - (n : Z) : Z;

    Definition (m : Z) mod (n : Z) : Z;

    Definition NN : ℘(Z) is {n : Z | ⌐(Is_Neg(n))};
        //won't typecheck at the moment
        //Corollary nn1: ∀ n : NN, suc(n) = NB(NB(n));
        //Corollary nn2: ∀ n : NN, suc(n) : NN;

    Definition (m : Z) > (n : Z) : B;

    Chainable Definition (m : Z) < (n : Z) : B;

    Chainable Definition (m : Z) ≤ (n : Z) : B is n + ⨩(m) ∈ NN;
        //Corollary leq1: Is_Transitive(≤);
        //Corollary leq2: Is_Antisymmetric(≤);
        //Corollary leq3: Is_Total(≤);

    Definition (m : Z) ≥ (n : Z) : B;

    Definition 1 : Z is suc(0);
        //Corollary one1: ∀ m : Z, suc(m) = (m + 1);

    /*Literal*/ Definition 2 : Z is suc(1);
    /*Literal*/ Definition 3 : Z is suc(2);
    /*Literal*/ Definition 4 : Z is suc(3);

    Inductive Definition (m : Z) * (n : Z) : Z is
        (i.) m * 0 = 0;
        (ii.) m * NB(n) = {{⨩(m * n) if Is_Neg(n); ⨩(m * n + m) otherwise; }};

    Theorem one_N: 1 = 1;

    Theorem I3: ∀ n : Z, ⌐(Is_Neg(n)) implies (suc(n) = NB(NB(n)));

	Theorem Addition_Over_Equality: ∀ i, j, k : Z, (i - j = k) = (i = (k + j));

	Theorem Addition_Over_LTEa: ∀ i, j, k : Z, (i + j ≤ k) = (i ≤ (k - j));

	Theorem Nested_Subt_1: ∀ i, j : Z, (i + (j - j)) = i;

	//Theorem Not_LTE: ∀ i, j : Z, ⌐(i ≤ j) = (j + 1 ≤ i);

	Corollary LTE_1a: ∀ i, j, k : Z, i ≤ j ∧ (j ≤ k) implies (i ≤ k);   //expand Is_Transitive(≤);
    //tod: Have special keyword which dictates when an application ought to be expanded.
    //For intance, Corollary lte1: expand Is_Transitive(≤);

    Corollary LTE_3: ∀ m, n : Z, m ≤ n ∨ (n ≤ m);       //expand Is_Total(≤)
	Corollary LTE_3a: ∀ n : Z, n ≤ n;                   //expand Is_Reflexive(≤)

end Basic_Integer_Theory;