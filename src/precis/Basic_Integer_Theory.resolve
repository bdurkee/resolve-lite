Precis Basic_Integer_Theory;
        uses (
            Monogenerator_Theory,
            Basic_Binary_Relation_Properties,
            Natural_Number_Theory
        );
    /** many theorems elided */
    Categorical Definition for â„¤ : SSet, 0 : â„¤, NB : â„¤ âŸ¶ â„¤ is
        Is_Monogeneric_for(â„¤, 0, NB);

    Inductive Definition Is_Neg(n : â„¤) : ğ”¹ is
        (i.) Is_Neg(n);
        (ii.) Is_Neg(NB(n)) = Â¬(Is_Neg(n));

    Inductive Definition â¨ª(n : â„¤) : â„¤ is
        (i.) â¨ª(0) = 0;
        (ii.) â¨ª(NB(n)) = {{n if Is_Neg(n); NB(NB(n)) otherwise; }};

    Inductive Definition suc(n : â„¤) : â„¤ is
        (i.) suc(0) = NB(NB(0));
        (ii.) suc(NB(n)) = {{NB(NB(NB(n))) if Is_Neg(n); â¨ª(n) otherwise;}};

    Inductive Definition (m : â„¤) + (n : â„¤) : â„¤ is
        (i.) m + 0 = m;
        (ii.) m + NB(n) = {{â¨ª(m) + n if Is_Neg(n);
                suc(â¨ª(m) + n) otherwise;}};

    Definition (m : â„¤) - (n : â„¤) : â„¤;

    Definition (m : â„¤) mod (n : â„¤) : â„¤;

    Definition NN : â„˜(â„¤) is {n : â„¤ | Â¬(Is_Neg(n))};

    Definition (m : â„¤) > (n : â„¤) : ğ”¹;

    Chainable Definition (m : â„¤) < (n : â„¤) : ğ”¹;

    Chainable Definition (m : â„¤) â‰¤ (n : â„¤) : ğ”¹ is n + â¨ª(m) âˆˆ NN;
        Corollary leq1: Is_Transitive(â‰¤);
        Corollary leq2: Is_Antisymmetric(â‰¤);
        Corollary leq3: Is_Total(â‰¤);

    Definition (m : â„¤) â‰¥ (n : â„¤) : ğ”¹;

    Definition 1 : â„¤ is suc(0);
        //Corollary one1: âˆ€ m : Z, suc(m) = (m + 1);

    /*Literal*/ Definition 2 : â„¤ is suc(1);
    /*Literal*/ Definition 3 : â„¤ is suc(2);
    /*Literal*/ Definition 4 : â„¤ is suc(3);

    Inductive Definition (m : â„¤) * (n : â„¤) : â„¤ is
        (i.) m * 0 = 0;
        (ii.) m * NB(n) = {{â¨ª(m * n) if Is_Neg(n); â¨ª(m * n + m) otherwise; }};

    Theorem one_N: 1 = 1;

    Theorem I3: âˆ€ n : â„¤, Â¬(Is_Neg(n)) âŸ¹ (suc(n) = NB(NB(n)));

	Theorem Addition_Over_Equality: âˆ€ i, j, k : â„¤, (i - j = k) = (i = (k + j));

	Theorem Addition_Over_LTEa: âˆ€ i, j, k : â„¤, (i + j â‰¤ k) = (i â‰¤ (k - j));

	Theorem Nested_Subt_1: âˆ€ i, j : â„¤, (i + (j - j)) = i;

	Theorem Not_LTE: âˆ€ i, j : â„¤, Â¬(i â‰¤ j) = (j + 1 â‰¤ i);

	Corollary LTE_1a: âˆ€ i, j, k : â„¤, i â‰¤ j âˆ§ (j â‰¤ k) âŸ¹ (i â‰¤ k);   //expand Is_Transitive(â‰¤);
    //tod: Have special keyword which dictates when an application ought to be expanded.
    //For intance, Corollary lte1: expand Is_Transitive(â‰¤);

    Corollary LTE_3: âˆ€ m, n : â„¤, m â‰¤ n âˆ¨ (n â‰¤ m);       //expand Is_Total(â‰¤)
	Corollary LTE_3a: âˆ€ n : â„¤, n â‰¤ n;                   //expand Is_Reflexive(â‰¤)

end Basic_Integer_Theory;