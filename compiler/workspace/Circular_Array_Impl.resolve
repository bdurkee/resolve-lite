Implementation Circular_Array_Impl for Queue_Template;
            uses Basic_Natural_Number_Theory, Standard_Integers,
                    String_Theory, Basic_Integer_Theory; //TODOTODO: These should be imported automatically
                    //since the base concept already imports em'
    Facility Arr_Fac is Bdd_Ceramic_Array_Template<E>(0, Max_Length - 1)
        externally implemented by Ceramic_Array_Impl;

    Type Queue = Record
        Contents : Arr_Fac :: Ceramic_Array;
        Prefront, Length : Std_Integer_Fac :: Integer;
    end;
    convention
        0 <= Q.Prefront < Max_Length and 0 <= Q.Length <= Max_Length;
    correspondence
        conc.Q = true;//Iterated_Concatenation(Q.Prefront + 1, Q.Prefront + Q.Length,
                 //   lambda(i : Z).(<Q.Contents(i mod Max_Length)>));

    Procedure Enqueue(alters e : E; updates Q : Queue);
        Var Temp : Std_Integer_Fac :: Integer;
        Q.Length := Q.Length + 1;
        Temp := Q.Prefront + Q.Length;
        Temp := Temp % Max_Length;
        Arr_Fac :: Swap_Element(Q.Contents, e, Temp);
    end Enqueue;

    Procedure Dequeue(replaces e : E; updates Q : Queue);
        Var Temp : Std_Integer_Fac :: Integer;
        Temp := Q.Prefront + 1;
		Q.Prefront := Temp % Max_Length;
		Arr_Fac :: Swap_Element(Q.Contents, e, Q.Prefront);
        Q.Length := Q.Length - 1;
    end Dequeue;

    Procedure Length(restores Q : Queue) :
        Std_Integer_Fac :: Integer; Length := Q.Length; end Length;

    Procedure Rem_Capacity(restores Q : Queue) : Std_Integer_Fac :: Integer;
        Rem_Capacity := Max_Length - Q.Length; end Rem_Capacity;

    Procedure Clear(clears Q : Queue);
        Q.Prefront := 0; Q.Length := 0; end Clear;
end Circular_Array_Impl;