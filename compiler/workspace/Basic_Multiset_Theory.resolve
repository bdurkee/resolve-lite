Precis Basic_Multiset_Theory;   @Dependent_Terms{aleph_nought}
        uses Basic_Integer_Theory;
    Definition Is_Multiset_like(MSet : Cls,
        m : MSet -> SSet, Tly_at : MSet * El -> Card,
        Multiset_Frmr : ((T : SSet) * (T -> Card)) -> MSet) : B;

    Categorical Definition for MSet : Cls,
        m : MSet -> SSet,
        Tly_at : MSet * El -> Card,
        Multiset_Frmr : ((T : SSet) * (T -> Card)) -> MSet
        is Is_Multiset_like(MSet, m, Tly_at, Multiset_Frmr);

    /** empty multiset */
    Definition Empty_Multiset : MSet is Multiset_Frmr(Empty_Set, ||Empty_Set||);
        Corollary EM1: Empty_Multiset = Empty_Set;
        Corollary EM2: Forall M : MSet,
            M = Empty_Set implies M = Empty_Multiset;

    /** singleton multiset */
    Definition \.../(x : El) : MSet;
        Corollary SM1: Forall z : El, \z/ = {z};
        Corollary SM2: Forall z : El, Tly_at(\z/, z) = 1;

    Definition multiset_union+(M, N : MSet) : MSet;
        Corollary MU1: Forall M, N : MSet,
            M multiset_union+ N = M multiset_union+ N;

    /** multiset union */
    Definition multiset_union(M, N : MSet) : MSet;

    /** multiset intersection */
    Definition multiset_intersect(M, N : MSet) : MSet;

    /** multiset minus */
    Definition multiset_minus(M, N : MSet) : MSet;

    Definition ||...||(x : MSet) : Card;

    Definition BMSet(S : SSet, k : Card) : SSet;

    Definition aleph_nought : Card;
    Definition FMSet(S : SSet) : SSet is
        {M : BMSet(S, aleph_nought) | ||M|| < aleph_nought};

end Basic_Multiset_Theory;