Precis String_Theory;
    uses Basic_Natural_Number_Theory;

	Definition Is_String_Former(str : Cls, empty_string : str,
	    ext : str * El -> (str ~ { empty_string })) : B;

	Categorical Definition for SStr : Cls, Empty_String : SStr,
	    ext : SStr * El -> SStr is
	    Is_String_Former(SStr, Empty_String, ext);

	Definition Str : Cls -> Cls;

	Implicit Definition Indcd_Fn(T, U : Cls, b : T -> U,
		s : T * U * SStr * El -> U, p : T * SStr * El -> T) : T * SStr -> U;
	Definition x : El;

	Inductive Definition on beta : SStr of o(alpha : SStr, beta) : SStr is
	(i.)  alpha o Empty_String = alpha;
	(ii.) alpha o ext(beta, x) = ext(alpha o beta, x);

	Inductive Definition on alpha : SStr of |...|(alpha) : N is
	(i.)  |Empty_String| = 0;
	(ii.) |ext(alpha, x)| = suc(|alpha|);

	Corollary C3: Forall alpha : SStr, |alpha| = 0 implies alpha = Empty_String
		and alpha = Empty_String implies |alpha| = 0;

	Definition <...>(x : El) : SStr is (ext(Empty_String, x));
	Corollary C4: Forall x : El, <x> /= Empty_String;
	Corollary C5: Forall x : El, |<x>| = 1;
	Corollary C6: Forall alpha : SStr, Forall x : El, alpha o <x> = ext(alpha, x);

	Inductive Definition on alpha : SStr of Reverse(alpha) : SStr is
	(i.)  Reverse(Empty_String) = Empty_String;
	(ii.) Reverse(ext(alpha, x)) = <x> o Reverse(alpha);
	Corollary RevC1: Forall x : El, Reverse(<x>) = <x>;
	Corollary RevC2: Forall alpha, beta : SStr,
		Reverse(alpha o beta) = Reverse(beta) o Reverse(alpha);
	Corollary RevC3: Forall alpha : SStr, Reverse(Reverse(alpha)) = alpha;

	--Implicit Definition >...<(p :

	(** Big Pi (Iterated Concatenation) Parameter of F is implicitly (m,m + n]
	 *  theorems assume it is defined this way: F(m + 1) o ... o F(m + n)
	 *)
	 Definition Iterated_Concatenation(m : N, n : N, F : N -> SStr) : SStr;

end String_Theory;