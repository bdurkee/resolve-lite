Facility Queue_Exercises_Fac;
    //this is an instructor version
    uses String_Theory, Standard_Booleans, Standard_Integers,
        Basic_Integer_Theory;

    Facility QF is Queue_Template<Std_Integer_Fac :: Integer>(5)
        implemented by Circular_Array_Impl;

    Operation Are_Equal(restores P, Q : QF :: Queue) :
                        Std_Boolean_Fac :: Boolean;
            ensures Are_Equal = (P = Q);
        Procedure
            Var Processed_P, Processed_Q : QF :: Queue;
            Var E, F : Std_Integer_Fac :: Integer;
            Are_Equal := true;
            If QF :: Length(P) /= QF :: Length(Q) then
                Are_Equal := false;
            else
                While 1 <= QF :: Length(P)
                    //maintaining Processed_P o P = #P and Processed_Q o Q = #Q and
                    //  |P| = |Q| and Are_Equal = (Processed_P = Processed_Q);
                    //decreasing |P|;
                do
                    QF :: Dequeue(E, P);
                    QF :: Dequeue(F, Q);
                    If E /= F then Are_Equal := false; end;
                    QF :: Enqueue(E, Processed_P);
                    QF :: Enqueue(F, Processed_Q);
                end;
                P :=: Processed_P;
                Q :=: Processed_Q;
            end;
    end Are_Equal;

    Operation Is_Present(restores I : Std_Integer_Fac :: Integer;
                         restores Q : QF :: Queue) : Std_Boolean_Fac :: Boolean;
            //ensures Is_Present = Is_Substring(<I>, Q);
        Procedure
            Var Processed_Q : QF :: Queue;
            Var F : Std_Integer_Fac :: Integer;

            Is_Present := false;
            While 1 <= QF :: Length(Q)
                //maintaining Processed_Q o Q = #Q and
                //    Is_Present = (Is_Substring(<E>, Processed_Q));
                //decreasing |Q|;
            do
                QF :: Dequeue(F, Q);
                If I = F then Is_Present := true; end;
                QF :: Enqueue(F, Processed_Q);
            end;
            Q :=: Processed_Q;
    end Is_Present;

    Operation Combine(updates P : QF :: Queue;
                      alters E : Std_Integer_Fac :: Integer;
                      clears Q : QF :: Queue);
            requires |P| + 1 + |Q| <= 1;
            ensures P = @P o <@E> o @Q;
        Procedure
            Var F : Std_Integer_Fac :: Integer;

            QF :: Enqueue(E, P);
            While 1 <= QF :: Length(Q)
               maintaining P o Q = #P o <#E> o #Q;
               // decreasing |Q|;
            do
                QF :: Dequeue(F, Q);
                QF :: Enqueue(F, P);
            end;
    end Combine;

    Operation Rotate(updates Q : QF :: Queue);
            requires 1 <= |Q|;
            ensures Q = Prt_Btwn(0, 1, @Q) o Prt_Btwn(1, |@Q|, @Q);
        Procedure
        Var E : Std_Integer_Fac :: Integer;
        QF :: Dequeue(E, Q);
        QF :: Enqueue(E, Q);
    end Rotate;

end Queue_Exercises_Fac;