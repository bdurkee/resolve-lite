Concept Bdd_Spiral_Template<T>
        (evaluates k, Max_Length : Std_Integer_Fac :: Integer); @DependentTerms{k}
            uses Basic_Integer_Theory, Basic_Spiral_Theory;
    requires k >= 2 and Max_Length > 0 which_entails k : N2;

    Type Family Spiral_Pos is modeled by Cart_Prod
            Lab : Sp_Loc(k) -> T;
            Curr_Loc, Trmnl_Loc : Sp_Loc(k);
        end;
        exemplar P;
        constraints SCD(k)(P.Trmnl_Loc) <= Max_Length and
            P.Curr_Loc is_in Inward_Loc(P.Trmnl_Loc); --and
            P.Lab(P.Trmnl_Loc) = T.Base_Point;
           -- P.Lab(Sp_Loc(k) ~ Inward_Loc(P.Trmnl_Loc)) = {T.Base_Point};
        initialization
                ensures P.Trmnl_Loc = Cen(k);

        Oper Lengthen (alters e : T; updates P : Spiral_Pos);
            requires SCD(k)(P.Trmnl_Loc) < Max_Length;
            ensures P.Trmnl_Loc = SS(k)(0, @P.Trmnl_Loc) and
                P.Curr_Loc = @P.Curr_Loc and
                P.Lab = lambda (q : Sp_Loc(k)).({{@e if q = @P.Trmnl_Loc;
                    @P.Lab(q) otherwise;}});

        Oper Spiral_Out (upd P : Spiral_Pos);
            requires SS(k)(0, P.Curr_Loc) is_in Inward_Loc(P.Trmnl_Loc);
            ensures P.Curr_Loc = SS(k)(0, @P.Curr_Loc) and
                P.Lab = @P.Lab and P.Trmnl_Loc = @P.Trmnl_Loc;

end Bdd_Spiral_Template;