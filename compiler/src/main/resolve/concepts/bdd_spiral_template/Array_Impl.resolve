Implementation Array_Impl for Bdd_Spiral_Template;
        uses Basic_Spiral_Theory;

    Facility Ceramic_Arr_Fac is Bdd_Ceramic_Array_Template
                <T>(0, Max_Length - 1)
        externally implemented by Ceramic_Array_Impl;

    Type Spiral_Pos = Record
            Labl : Ceramic_Arr_Fac :: Ceramic_Array;
            Length, Curr_Place : Std_Integer_Fac :: Integer;
        end;
        convention 0 <= P.Curr_Place and P.Curr_Place <= P.Length
                        and P.Length <= Max_Length
                    which_entails P.Curr_Place, P.Length : N;
        correspondence conc.P.Trmnl_Loc = SS(Cen, P.Length) and
                       conc.P.Curr_Loc = SS(Cen, P.Curr_Place);
        initialization
            P.Length := 0;
            P.Curr_Place := 0;
        end;

      (**  Proc Lengthen (alters e : T; updates P : Spiral_Pos);
            --duration Is_Big_Theta(0);
            Ceramic_Arr_Fac :: Swap_Element(P.Labl, e, P.Length);
            P.Length := P.Length + 1;
        end Lengthen;*)

end Array_Impl;

(**
--------------------------
L E N G T H E N:
--------------------------
1. Apply procedure decl rule
C / ASSUME  0 <= P.Curr_Place <= P.Length <= Max_Length and
            SCD(P.Trmnl_Loc) < Max_Length;
    REMEMBER;
        Ceramic_Arr_Fac :: Swap_Element(P.Labl, e, P.Length);
        P.Length := P.Length + 1;
    CONFIRM P.Trmnl_Loc = SS(@P.Trmnl_Loc, 0) and
            P.Curr_Loc = @P.Curr_Loc and
            P.Lab = lambda (q : Sp_Loc).(
                {{@e if q = @P.Trmnl_Loc; @P.Lab(q) otherwise; }}) and
            0 <= P.Curr_Place <= P.Length <= Max_Length

2. apply call simple call rule (Sum)
C / ASSUME  0 <= P.Curr_Place <= P.Length <= Max_Length and
            SCD(P.Trmnl_Loc) < Max_Length;
    REMEMBER;
        Ceramic_Arr_Fac :: Swap_Element(P.Labl, e, P.Length);
        P.Length := P.Length + 1;
    CONFIRM
            min_int <= i + j <= max_int [i -> P.Length, j -> 1] and
            P.Trmnl_Loc = SS(@P.Trmnl_Loc, 0) and
            P.Curr_Loc = @P.Curr_Loc and
            P.Lab = lambda (q : Sp_Loc).(
                {{@e if q = @P.Trmnl_Loc; @P.Lab(q) otherwise; }}) and
            0 <= P.Curr_Place <= P.Length <= Max_Length
            [P.Length -> Sum = ( i + j )[i -> P.Length, j -> 1]]
------------------------------>
    CONFIRM
            min_int <= P.Length + 1 <= max_int and
            conc.P.Trmnl_Loc = SS(@conc.P.Trmnl_Loc, 0) and
            conc.P.Curr_Loc = @conc.P.Curr_Loc and
            conc.P.Lab = lambda (q : Sp_Loc).(
                {{@e if q = @P.Trmnl_Loc; @P.Lab(q) otherwise; }}) and
            0 <= P.Curr_Place <= P.Length <= Max_Length
            [P.Length -> Sum = ( i + j )[i -> P.Length, j -> 1]]
*)