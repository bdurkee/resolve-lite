Concept Prioritizer_Template(type Entry;
            evaluates Max_Capacity : Std_Ints :: Integer;
            Definition LEQV(x, y : Entry) : B;);
        uses Standard_Booleans, Standard_Integers,
            Basic_Integer_Theory, Basic_Natural_Number_Theory;

        requires Max_Capacity > 0
            which_entails Max_Capacity : N;

    Definition Total_Entry_Ct(K : Entry -> N) : N;

    Type family Entry_Keeper
                is modeled by Cart_Prod
                    Entry_Count : Entry -> N;
                    Accepting : B;
        end;
        exemplar K;
        constraints Total_Entry_Ct(K.Entry_Count) <= Max_Capacity;
        initialization
            ensures K.Accepting = true and
                Total_Entry_Ct(K.Entry_Count) = 0;

    Definition Is_Only_Addition(K1, K2 : Entry_Keeper, e : Entry) : B is
        K2.Entry_Count(x) = K1.Entry_Count(x) + 1 and
            (Forall y : Entry,
                y /= x implies K2.Entry_Count(y) = K1.Entry_Count(y));

    Operation Add_Entry (updates K : Entry_Keeper; clears x : Entry);
        requires Total_Entry_Ct(K.Entry_Count) < Max_Capacity and K.Accepting;
        ensures Is_Only_Addition(@x, @K, K) and K.Accepting;

    Operation Change_Modes (updates K : Entry_Keeper);
         ensures K.Accepting = not(@K.Accepting) and
            K.Entry_Count = @K.Entry_Count;

    Definition leqvs(x, y : Entry) : B is LEQV(x, y) and not(LEQV(y, x));

    Operation Remove_a_Smallest_Entry (updates K : Entry_Keeper;
                                       replaces e : Entry);
        requires K.Accepting = false and Total_Entry_Ct(K.Entry_Count) > 0;
        ensures K.Accepting = false and Is_Only_Addition(e, K, @K) and
            (Forall x : Entry,
                    leqvs(x, e) implies @K.Entry_Count(x) = 0);

    Operation Total_Entry_Count (restores K : Entry_Keeper)
                : Std_Ints :: Integer;
        ensures Total_Entry_Count = (Total_Entry_Ct(K.Entry_Count));
end Prioritizer_Template;