Concept Bdd_Spiral_Template(type Label;
            evaluates k, Max_Length :
                        Std_Ints :: Integer);
        uses Standard_Integers, Standard_Booleans,
             Basic_Natural_Number_Theory,
             Basic_Function_Properties,
             Basic_Spiral_Theory;
    requires k >= 2 and Max_Length > 0
            which_entails
                Max_Length : N;

    Type family Spiral_Pos
        is modeled by Cart_Prod
            Lab : Sp_Loc(k) -> Label;
            Curr_Loc,
            Trmnl_Loc : Sp_Loc(k);
        end;
        exemplar P;
        constraints
            SCD(P.Trmnl_Loc) <= Max_Length and
            P.Curr_Loc is_in
                Inward_Loc(P.Trmnl_Loc);
        initialization
            ensures
                P.Trmnl_Loc = Cen(k);

    Operation Lengthen (updates P : Spiral_Pos;
                        alters e : Label);
        requires
            SCD(P.Trmnl_Loc) < Max_Length;
        ensures P.Trmnl_Loc = SS(k)(@P.Trmnl_Loc) and
                P.Curr_Loc = @P.Curr_Loc and
                P.Lab = lambda (q : Sp_Loc(k)).(
                    {{@e if q = @P.Trmnl_Loc;
                    @P.Lab(q) otherwise;}});

    Operation Spiral_Out (updates P : Spiral_Pos);
        requires SS(k)(P.Curr_Loc) is_in
            Inward_Loc(P.Trmnl_Loc);
        ensures P.Curr_Loc =
            SS(k)(@P.Curr_Loc) and
                P.Lab = @P.Lab and
                P.Trmnl_Loc = @P.Trmnl_Loc;
                
    Operation Spiral_In (updates P : Spiral_Pos);
        requires P.Curr_Loc /= Cen(k);
        ensures @P.Curr_Loc =
            SS(k)(P.Curr_Loc) and
                P.Lab = @P.Lab and
                P.Trmnl_Loc = @P.Trmnl_Loc;

    Operation Swap_Label (updates P : Spiral_Pos;
                          updates e : Label);
        requires P.Curr_Loc /= P.Trmnl_Loc;
        ensures P.Trmnl_Loc = @P.Trmnl_Loc and
            P.Curr_Loc = @P.Curr_Loc and
            e = @P.Lab(P.Curr_Loc) and
            P.Lab = lambda (q : Sp_Loc(k)).(
                {{@e if q = P.Curr_Loc;
                @P.Lab(q) otherwise;}});

    Operation Hop_Out (updates P : Spiral_Pos);
        requires RS(k)(P.Curr_Loc) is_in
            Inward_Loc(P.Trmnl_Loc);
        ensures P.Curr_Loc = RS(k)(@P.Curr_Loc) and
            P.Lab = @P.Lab and
            P.Trmnl_Loc = @P.Trmnl_Loc;

    Operation Move_to_End (updates P : Spiral_Pos);
        ensures P.Curr_Loc = @P.Trmnl_Loc and
            P.Trmnl_Loc = @P.Trmnl_Loc and
            P.Lab = @P.Lab;

    Operation Move_to_Center (updates P : Spiral_Pos);
        ensures P.Curr_Loc = Cen(k) and
            P.Lab = @P.Lab and
            P.Trmnl_Loc = @P.Trmnl_Loc;

    Operation Length_of (restores P : Spiral_Pos)
            : Std_Ints :: Integer;
        ensures Length_of = SCD(P.Trmnl_Loc);

    Operation Curr_Ctr_Dist (restores P : Spiral_Pos)
            : Std_Ints :: Integer;
        ensures Curr_Ctr_Dist = SCD(P.Curr_Loc);

    Operation At_Edge (restores P : Spiral_Pos)
            : Std_Bools :: Boolean;
        ensures At_Edge =
            not(RS(P.Curr_Loc) is_in
                    Inward_Loc(P.Trmnl_Loc));

    Operation Clear (clears P : Spiral_Pos);

end Bdd_Spiral_Template;